# Can you give me the sagemath code to construct the following matrices: \diag(x, x^-1), where x is the real number such that x+x^-1=3; (a,b\\c,d) with determinant 1, where a=3x/(x+1) and d=3/(x+1), and b=1 

# Define the variable and solve the equation
x = var('x')
sols = solve(x + 1/x == 3, x, solution_dict=True)

# Choose the positive real root
x_val = sols[0][x].n()  # Since x + 1/x = 3, x ≈ (3 + sqrt(5))/2

# Define matrices using this value
x_real = RR(x_val)      # Convert to real number

# First matrix: diag(x, x^-1)
M1 = diagonal_matrix([x_real, 1/x_real])

# Define a, d, b
a = 3 / (x_real + 1)
d = 3 * x_real / (x_real + 1)
b = 1

# Compute c to make det = 1: ad - bc = 1 => c = (ad - 1)/b
c = (a*d - 1) / b

# Second matrix
M2 = matrix([[a, b], [c, d]])

# Output the matrices
print("Matrix 1 (diag(x, 1/x)):")
show(M1)

print("Matrix 2 ([[a, b], [c, d]]):")
show(M2)
# Continue from previous values of x_real, a, b, c, d

# Define the variable for RP^1
z = var('z')

# Function to compute real fixed points of Möbius transformation
def real_fixed_points(a, b, c, d):
    # Solve (az + b)/(cz + d) = z
    f = c*z^2 + (d - a)*z - b
    roots = solve(f == 0, z, solution_dict=True)
    # Filter only real roots
    real_roots = [r[z].n() for r in roots if r[z].imag() == 0]
    return real_roots

# First matrix: diag(x, 1/x)
# In SL_2(R), diag(x, 1/x) acts as z ↦ x^2 * z
# So fixed points are 0 and ∞ (or the line through e1 and e2)
fixed_M1 = ["0", "infinity"]  # Möbius transformation is z ↦ x^2 * z

# Second matrix: [[a, b], [c, d]]
fixed_M2 = real_fixed_points(a, b, c, d)

# Output results
print("Fixed points of matrix 1 (diag):")
show(fixed_M1)

print("Fixed points of matrix 2:")
show(fixed_M2)

# Compute real fixed points of M2
fixed_pts = real_fixed_points(a, b, c, d)
z1, z2 = fixed_pts  # real numbers, endpoints of the geodesic



# Define the variable and solve the equation
x = var('x')
sols = solve(x + 1/x == 3, x, solution_dict=True)

# Choose the positive real root
x_val = sols[0][x].n()  # Since x + 1/x = 3, x ≈ (3 + sqrt(5))/2

# Define matrices using this value
x_real = RR(x_val)      # Convert to real number

# First matrix: diag(x, x^-1)
M1 = diagonal_matrix([x_real, 1/x_real])

# Define a, d, b
a = 3 / (x_real + 1)
d = 3 * x_real / (x_real + 1)
b = 1

# Compute c to make det = 1: ad - bc = 1 => c = (ad - 1)/b
c = (a*d - 1) / b

# Second matrix
M = matrix( [[a, b], [c, d]])

# Fixed points (real roots of the quadratic equation)
R.<z> = PolynomialRing(RDF)
poly = c*z^2 + (d - a)*z - b
roots = poly.roots(multiplicities=False)
f, g = roots

# Midpoint x value
x0 = (f + g) / 2

# Sample vertical line in upper half-plane
y_vals = [i/20 for i in range(1, 100)]
points = [x0 + I*y for y in y_vals]

# Apply powers of M to the line
powers = [-3, -2, -1, 0, 1, 2, 3]
colors = rainbow(len(powers))
transformed_lines = []

for i, n in enumerate(powers):
    Mn = M^n
    T = lambda z: (Mn[0,0]*z + Mn[0,1]) / (Mn[1,0]*z + Mn[1,1])
    transformed_points = [T(z) for z in points if (Mn[1,0]*z + Mn[1,1]) != 0]
    transformed_lines.append(line([(z.real(), z.imag()) for z in transformed_points], color=colors[i]))

# Plotting
plot_original = line([(z.real(), z.imag()) for z in points], color='black', thickness=2)
final_plot = sum(transformed_lines) + plot_original
#final_plot.show(aspect_ratio=1, figsize=[10,10])
# Parameters you can adjust later
t = 1
x = x_real

# Range of n (e.g., from -3 to 3)
n_values = range(-5, 5)

# Draw circles centered at (0,0) with radius t*(2*x)^n
circles = []
for n in n_values:
    radius = t * (2*x)**n
    c = circle((0,0), radius, color='blue', linestyle='--', thickness=1)
    circles.append(c)

# Combine circles into one plot
circles_plot = sum(circles)

# Add to existing Möbius transformation plot from before
final_plot_with_circles = final_plot + circles_plot

# Show with aspect ratio fixed
final_plot_with_circles.show(aspect_ratio=1, figsize=[7,7])
